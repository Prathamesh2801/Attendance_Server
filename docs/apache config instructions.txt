Nice — here’s a clear, copy-pasta friendly list of the packages and tools you should install on a Hostinger (Ubuntu/Debian) VPS to reproduce and maintain the workflow you showed (git clone → Node backend under PM2 → Apache serving a built frontend). I’ll also include the exact commands in the order you should run them and a one-line reason for each item.

> Assumes a Debian/Ubuntu-based VPS (Hostinger usually uses those). Run these as a user with `sudo` privileges.

# 1 — Basic system tools

```bash
sudo apt update
sudo apt install -y curl wget git unzip build-essential
```

* `curl`, `wget` — download files/scripts.
* `git` — clone your repo.
* `unzip` — extract frontend `dist.zip`.
* `build-essential` — compilers/tools some npm modules might need.

# 2 — Node.js + npm (install current LTS)

```bash
curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
sudo apt install -y nodejs
```

* Installs Node.js LTS and `npm`. Required to run your backend (npm start) and to install pm2.

# 3 — PM2 (process manager for Node)

```bash
sudo npm install -g pm2
# set up pm2 to start at boot (run the printed command afterwards)
sudo pm2 startup systemd
# after starting processes run:
pm2 save
```

* Keeps your Node app running and restarts on reboot.

# 4 — Apache web server (you used apache)

```bash
sudo apt install -y apache2
# enable modules commonly used for reverse proxy / SPA
sudo a2enmod proxy proxy_http rewrite headers
sudo systemctl restart apache2
sudo systemctl enable apache2
```

* Serves the frontend files from `/var/www/html` and can reverse-proxy requests to your backend if desired.

# 5 — TLS / Certbot for HTTPS (optional but recommended)

```bash
sudo apt install -y certbot python3-certbot-apache
# then run:
sudo certbot --apache -d yourdomain.com -d www.yourdomain.com
```

* Lets you get/renew Let's Encrypt certificates and configure Apache automatically.



Good question 👍 — that table shows a **broken/errored PM2 process** (`name: -a`, `status: errored`), which you can safely remove or clean up.

Here’s exactly how to remove it **completely and clean your PM2 list**:

---

## 🧹 Step-by-Step: Remove unwanted PM2 processes

### 1️⃣  Check all running / saved processes

```bash
pm2 list
```

or

```bash
pm2 status
```

You’ll see entries like the one you posted (`id 0 │ -a │ errored`).

---

### 2️⃣  Delete that process from PM2

You can delete by **id** or **name**:

```bash
pm2 delete 0
```

or if the process had a name, e.g. `backend`:

```bash
pm2 delete backend
```

✅ This immediately removes it from the PM2 process list (and stops it if running).

---

### 3️⃣  Save the cleaned process list

To ensure PM2 doesn’t resurrect that process after reboot:

```bash
pm2 save
```

This updates PM2’s dump file (`~/.pm2/dump.pm2`) so only the currently running processes are saved for restart.

---

### 4️⃣  (Optional) View the cleaned list

```bash
pm2 list
```

Now it should show **no errored entries** — only your valid processes.

---

### 5️⃣  (Optional) If you want to reset PM2 completely

If you want to **wipe out all processes, logs, and saved data**, use:

```bash
pm2 delete all
pm2 save
```

and then (optional hard reset):

```bash
pm2 kill
rm -rf ~/.pm2
```

⚠️ This removes all PM2 configuration and logs for the root user — start fresh afterward.

---

### ✅ Typical cleanup sequence for your case

Since your only entry is that broken `-a` one:

```bash
pm2 delete 0
pm2 save
pm2 list
```

You should now see:

```
┌────┬───────┬─────────────┬─────────┬────────┬────────┐
│ id │ name  │ namespace   │ status  │ cpu    │ mem    │
└────┴───────┴─────────────┴─────────┴────────┴────────┘


Prompt : - like i install certbot and it working fine for port 80 but not for port 5000 or different port

Right — that’s expected behavior. Let me explain why and give you exact, copy-paste steps to make HTTPS work for your app that listens on port **5000** (or any other non-standard port) by using Apache as a reverse proxy with a Let’s Encrypt certificate.

### Why Certbot “works for port 80 but not 5000”

* Let’s Encrypt issues certificates for **domain names**, not ports.
* The common challenge methods (HTTP-01, TLS-ALPN-01) require the ACME server to reach **port 80** (HTTP) or **port 443** (HTTPS) on your domain to validate ownership. It **will not** validate on random ports like `:5000`.
* So you *cannot* request a public Let's Encrypt cert directly for `example.com:5000`. You request it for `example.com` (using ports 80/443), and then use that cert to secure traffic to your site — usually by reverse-proxying traffic from Apache/Nginx (80/443) to your app on `localhost:5000`.

---

## Two safe approaches (recommended)

### A) Recommended — Use Apache as reverse proxy + certbot (simplest & robust)

Apache handles HTTPS for `yourdomain.com` and forwards API calls to your Node app on port 5000. This is best for production.

**1. Create an Apache VirtualHost for your domain**

Create `/etc/apache2/sites-available/yourdomain.conf` (replace `yourdomain.com`):

```apache
<VirtualHost *:80>
    ServerName yourdomain.com
    ServerAlias www.yourdomain.com

    # Serve frontend files (if any) from /var/www/html or a different docroot:
    DocumentRoot /var/www/html

    # Proxy /api to your backend on port 5000
    ProxyPreserveHost On
    ProxyRequests Off
    ProxyPass /api http://127.0.0.1:5000/api
    ProxyPassReverse /api http://127.0.0.1:5000/api

    # Optional: send all unknown requests to index.html (for SPA)
    <Directory /var/www/html>
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/yourdomain_error.log
    CustomLog ${APACHE_LOG_DIR}/yourdomain_access.log combined
</VirtualHost>
```

Enable site and modules:

```bash
sudo a2enmod proxy proxy_http rewrite headers
sudo a2ensite yourdomain.conf
sudo systemctl reload apache2
```

**2. Obtain and install the certificate with Certbot (Apache plugin)**

```bash
sudo apt update
sudo apt install -y certbot python3-certbot-apache

sudo certbot --apache -d yourdomain.com -d www.yourdomain.com
```

Certbot will verify via port 80, obtain certs, and automatically edit your Apache config to add the `:443` VirtualHost with SSL configuration.

**3. Restart Apache and test**

```bash
sudo systemctl reload apache2
# test:
curl -vk https://yourdomain.com/api/health
```

Your browser should show `https://yourdomain.com` on port 443; Apache will forward `/api` requests to your Node app on port 5000.

---

### B) Alternate — Let Node use the certificate files directly

If you want Node to serve HTTPS on port 443 itself (less common when you already use Apache), you must:

* Use `certbot certonly` to obtain cert files (Apache must not be using port 80 during validation OR use DNS challenge),
* Configure your Node app to read `/etc/letsencrypt/live/yourdomain.com/fullchain.pem` and `privkey.pem` and listen on **443**,
* Ensure your app restarts when certs renew (or use a reload hook).

This method requires Node to bind to privileged port 443 (or run via systemd with capabilities) and is more work. Reverse proxy is simpler and recommended.

---

## Troubleshooting tips / gotchas

* **DNS must point to your VPS public IP** for `yourdomain.com`. Let’s Encrypt validates that.
* If **Apache is already running** on port 80, run certbot with the `--apache` plugin (it uses Apache to respond to challenges). If you use `--standalone`, stop Apache first.
* **Firewall**: allow ports 80 and 443 (`sudo ufw allow http`, `sudo ufw allow https`).
* **Localhost binding**: ProxyPass should point to `127.0.0.1:5000` (or whatever host/port your Node listens to).
* **Paths**: ensure your API endpoints and ProxyPass paths match (e.g., `/api` → `/api`).
* After cert renewal, Apache reloads automatically if installed via `--apache`; test with:

  ```bash
  sudo certbot renew --dry-run
  ```

---

## Quick checklist (copy-paste)

```bash
# install certbot apache plugin
sudo apt update
sudo apt install -y certbot python3-certbot-apache

# enable proxy modules (if not already)
sudo a2enmod proxy proxy_http rewrite headers
sudo systemctl reload apache2

# create/enable site config (edit /etc/apache2/sites-available/yourdomain.conf accordingly)
sudo a2ensite yourdomain.conf
sudo systemctl reload apache2

# get certs using apache plugin
sudo certbot --apache -d yourdomain.com -d www.yourdomain.com

Prompt :-  can i also do for pm2 cert ?

Good — this is the right place to configure your reverse proxy. ✅
Here’s exactly how to handle this step-by-step 👇

---

### 🔹 Step-by-Step Setup

#### **1. Don’t edit the default files directly.**

Instead of editing `000-default.conf`, create a **new config file** for your domain — this keeps your setup clean and easier to manage later.

Run:

```bash
cd /etc/apache2/sites-available
sudo nano yourdomain.conf
```

Then paste your config:

```apache
<VirtualHost *:80>
    ServerName yourdomain.com
    ServerAlias www.yourdomain.com

    # Serve your frontend build files (React/Vite etc.)
    DocumentRoot /var/www/html

    # Proxy API requests to Node.js backend running on port 5000
    ProxyPreserveHost On
    ProxyRequests Off
    ProxyPass /api http://127.0.0.1:5000/api
    ProxyPassReverse /api http://127.0.0.1:5000/api

    # Handle React/Vite SPA routes (so refreshing /dashboard etc. works)
    <Directory /var/www/html>
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/yourdomain_error.log
    CustomLog ${APACHE_LOG_DIR}/yourdomain_access.log combined
</VirtualHost>
```

Press **CTRL+O → ENTER → CTRL+X** to save and exit.

---

#### **2. Enable the site**

```bash
sudo a2ensite yourdomain.conf
```

Then reload Apache:

```bash
sudo systemctl reload apache2
```

---

#### **3. Disable the default site (optional but recommended)**

```bash
sudo a2dissite 000-default.conf
sudo systemctl reload apache2
```

---

#### **4. Issue/attach SSL certificate**

If you already installed `certbot`, run:

```bash
sudo certbot --apache -d yourdomain.com -d www.yourdomain.com
```

This will automatically:

* Create an SSL version of your config (like `yourdomain-le-ssl.conf`)
* Redirect HTTP → HTTPS

---

#### **5. Verify it works**

* Visit `http://yourdomain.com` — should show your frontend.
* Open browser dev tools → Network tab → check if API requests (`/api/...`) go through and reach your backend on port 5000.

---

✅ **Summary:**

* Create a new file: `/etc/apache2/sites-available/yourdomain.conf`
* Put your `<VirtualHost>` block there
* Enable it using `a2ensite`
* Restart or reload Apache
* Run certbot to add HTTPS

---

Would you like me to show you **how to make the HTTPS version** (`<VirtualHost *:443>`) manually — in case you want to understand what Certbot generates automatically?


Prompt :- im getting this Not Found The requested URL was not found on this server. Apache/2.4.58 (Ubuntu) Server at studentinfoapp.i-tech.net.in Port 443 https://studentinfoapp.i-tech.net.in/api/test

# from your project directory (or anywhere)
curl -v http://127.0.0.1:5000/api/test


Response : - 
root@srv807475:/etc/apache2/sites-available# curl -v http://127.0.0.1:5000/api/test
*   Trying 127.0.0.1:5000...
* Connected to 127.0.0.1 (127.0.0.1) port 5000
> GET /api/test HTTP/1.1
> Host: 127.0.0.1:5000
> User-Agent: curl/8.5.0
> Accept: */*
> 
< HTTP/1.1 200 OK
< Access-Control-Allow-Origin: *
< Access-Control-Allow-Methods: GET, POST, OPTIONS, PUT, DELETE
< Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With
< Access-Control-Allow-Credentials: true
< Content-Type: application/json
< Date: Mon, 13 Oct 2025 07:13:07 GMT
< Connection: keep-alive
< Keep-Alive: timeout=5
< Transfer-Encoding: chunked
< 
* Connection #0 to host 127.0.0.1 left intact
{"success":true,"message":"Server OK","database":2}root@srv807475:/etc/apache2/sites-available# 

Perfect — your backend is healthy (returns `200`), so the 404 is definitely an Apache config issue. Most likely Certbot created/activated the `*:443` vhost (`000-default-le-ssl.conf`) but that SSL vhost does **not** contain your proxy rules. Add the same proxy block into the `*:443` VirtualHost and reload Apache.

Do these exact steps (copy-paste):

1. Open the SSL vhost file for editing (Certbot usually created `000-default-le-ssl.conf` — that’s the one you listed):

```bash
sudo nano /etc/apache2/sites-available/000-default-le-ssl.conf
```

2. Inside that file find the `<VirtualHost *:443>` block. Add the proxy lines (use trailing slashes) somewhere inside that block — for example just after `DocumentRoot` or before `</VirtualHost>`:

```apache
    # Proxy API requests to Node.js backend on port 5000
    ProxyPreserveHost On
    ProxyRequests Off

    # Use trailing slashes to avoid prefix/path issues
    ProxyPass        /api/ http://127.0.0.1:5000/api/
    ProxyPassReverse /api/ http://127.0.0.1:5000/api/
```

So a minimal example inside `000-default-le-ssl.conf` will look like:

```apache
<VirtualHost *:443>
    ServerName studentinfoapp.i-tech.net.in
    ServerAlias www.studentinfoapp.i-tech.net.in

    DocumentRoot /var/www/html

    SSLEngine on
    SSLCertificateFile /etc/letsencrypt/live/studentinfoapp.i-tech.net.in/fullchain.pem
    SSLCertificateKeyFile /etc/letsencrypt/live/studentinfoapp.i-tech.net.in/privkey.pem
    Include /etc/letsencrypt/options-ssl-apache.conf

    ProxyPreserveHost On
    ProxyRequests Off
    ProxyPass        /api/ http://127.0.0.1:5000/api/
    ProxyPassReverse /api/ http://127.0.0.1:5000/api/

    <Directory /var/www/html>
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/studentinfoapp_error.log
    CustomLog ${APACHE_LOG_DIR}/studentinfoapp_access.log combined
</VirtualHost>
```

3. Test Apache config and reload:

```bash
sudo apachectl configtest
sudo systemctl reload apache2
```

If `apachectl configtest` reports `Syntax OK`, proceed. If it errors, paste the error here.

